
/*
ANOTAÇÕES DE ESTUDOS DE SQL


-- SQL - STRUCTURED QUERY LANGUAGE

LINGUAGEM DE PROGRAMAÇÃO UTILIZADA PARA LIDAR COM BANCOS DE DADOS RELACIONAIS
ELE É DEFINIDO EM:
DDL - DATA DEFINITION LANGUAGE (CREATE, DROP, ALTER, TRUNCATE)
DML - DATA MANIPULATION LANGUAGE (INSERT, UPDATE, DELETE, MERGE)
DQL - DATA QUERY LANGUAGE (SELECT)
DCL - DATA CONTROL LANGUEGE (GRANT, REVOKE)
DTL - DATA TRANSATION LANGUAGE (COMMIT, ROLLBACK, SAVEPOINT)
*/

/*
-- DQL
SELECT
SELECT É UMA CONSULTA QUE TRAZ O QUE VOCÊ QUISER VISUALIZAR
SELECT * OU SELECT DISTINCT
*/

SELECT * FROM clientes;
SELECT * FROM pedidos;
-- TENHO DOIS SELECTS DE CLIENTES E O DE PEDIDOS, O PROGRAMA ME RETORNOU AS DUAS TABELAS INTEIRAS

SELECT
	NOME,
	SOBRENOME,
    EMAIL
FROM
	clientes;
-- CADA CONSULTA É ABERTA EM UMA NOVA ABA
-- A NOVA CONSULTA RETORNOU APENAS AS COLUNAS QUE FORAM ESPECIFICADAS

SELECT DATA_VENDA AS 'DATA', ID_PRODUTO  AS 'ID', QTD_VENDIDA 'QUANTIDADE' FROM pedidos;
-- É POSSÍVEL DAR NOME AS COLUNAS COM O COMANDO AS E COLOCANDO O NOME QUE VOCÊ QUISER ENTRE ASPAS

SELECT * FROM pedidos LIMIT 20;
-- COM A OPÇÃO LIMIT, VOCÊ LIMITA AS CONSULTAS REALIZADAS AO OPERADOR COLOCADO NO CÓDIGO


/*
ORDENAR CONSULTAS

É FEITO PELO APLICANDO O COMANDO ORDER BY NO CÓDIGO
ESSE COMANDO ORGANIZA AS CONSULTAS DA FORMA QUE O USUÁRIO ORDENAR

*/

SELECT
	*
FROM
	clientes
ORDER BY
	NOME,
    SOBRENOME;
-- COLOCAR O CÓDIGO QUEBRADO DEIXA ELE MAIS ORDENADO, O ; É O QUE FINALIZA.

SELECT
	* 
FROM
	clientes
ORDER BY
	Renda_Anual DESC
LIMIT 20;
-- ASC E DESC APÓS O NOME DA COLUNA ALTERA SE É ASCENDENTE OU DESCENTE.

SELECT
	Nome,
	Sobrenome,
    Sexo AS 'Genero',
    Data_Nascimento
FROM
	clientes
ORDER BY Data_Nascimento DESC;

/*
FILTROS

OS FILTROS NO SQL AUXILIAM A TORNAR AS CONSULTAS MAIS ESPECÍFICAS
-- WHERE
-- AND/OR
-- IS NULL/ IS NOT NULL
-- LIKE
-- IN
-- BETWEEN
*/

/*
WHERE
 FILTRO QUE ESPECIFICA ONDE DEVE SER ENCONTRADAS AS INFORMAÇÕES QUE SERÃO RETORNADAS NAS PESQUISAS
*/
SELECT
	*
FROM
	clientes
WHERE
	sexo = 'F';

-- OUTRO EXEMPLO
SELECT
	*
FROM
	clientes
WHERE
	Renda_Anual > 50000;

-- MAIS UM EXEMPLO
SELECT
	*
FROM
	pedidos
WHERE
	Data_Venda = '2019-03-10';

-- O FORMATO DA PESQUISA TEM DE SEMPRE RESPEITAR O FILTRO
SELECT
	Preco_Unit AS 'Preco'
FROM
	pedidos
WHERE
	Preco_Unit = 350;

-- MAIS UM EXEMPLO
SELECT
	CUSTO_VENDA AS 'CUSTO'
FROM
	PEDIDOS
WHERE CUSTO_VENDA >= 500 ORDER BY CUSTO_VENDA DESC;

-- ULTIMO EXEMPLO
SELECT
	*
FROM
	clientes
WHERE
	ESTADO_CIVIL = 'S' AND SEXO = 'M';

/*
AND/ OR / NOT(não)
PODEM ADICIONAR MAIS OPÇÕES DE LOCAIS PARA PROCURAR OU AJUDAR A LIMITAR AINDA MAIS
"OR" ADICIONA FILTROS PARA SEREM USADOS ALTERNATIVAMENTE SEM EXCLUIR O OUTRO, ENQUANTO "AND" ACRESCENTA AS CONDIÇÕES PARA SEREM USADAS CUMULATIVAMENTE DEIXANDO MAIS ESPECÍFICO
*/
select * FROM PEDIDOS
WHERE ID_LOJA = '5' AND PRECO_UNIT = '780';
-- EXEMPLO 02 - OR
select * FROM PRODUTOS
WHERE MARCA_PRODUTO = 'DELL' OR MARCA_PRODUTO = 'BLUE';
-- EXEMPLO 03 - NOT: ESSE EXEMPLO VAI FAZER UMA NEGAÇÃO, COMO POR EXEMPLO TODOS OS PRODUTOS QUE NÃO FOSSEM DA MARCA X OU Y
select * FROM PRODUTOS
WHERE NOT MARCA_PRODUTO = 'DELL';

-- OUTROS 03 EXEMPLOS, UM COM AND, UM COM OR E OUTRO COM WHERE NOT E AND
select * FROM PRODUTOS
WHERE MARCA_PRODUTO = 'DELL' AND PRECO_UNIT >= 2000;

SELECT * FROM PRODUTOS
WHERE MARCA_PRODUTO = 'DELL' OR MARCA_PRODUTO = 'ALTURA' AND PRECO_UNIT > '1500';

SELECT * FROM PRODUTOS
WHERE NOT MARCA_PRODUTO = 'DELL' AND PRECO_UNIT >= '1500';


/*
IS NULL OU IS NOT NULL
PARA FILTRAR VALORES NULOS OU QUE NÃO SÃO NULOS
*/
SELECT * FROM CLIENTES
WHERE TELEFONE IS NULL;
-- COM ESSES COMANDOS FORAM SELECIONADOS APENAS OS CLIENTES QUE NÃO CADASTRARAM OS TELEFONES
SELECT *FROM LOJAS
WHERE TELEFONE IS NULL;
-- EXEMPLO 3
-- NÃO CONFUNDIR NULL COM VAZIO. PARA ACHAR VALORES VAZIOS É PRECISO COLOCAR O COMANDO ''
SELECT * FROM CLIENTES
WHERE TELEFONE = '' OR TELEFONE IS NULL;


/*
LIKE

É PARA TRAZER TODAS AS LINHAS EM QUE O VALOR É PARECIDO COM O QUE FOI COLOCADO
O COMANDO LIKE TEM DE VIR JUNTO DE UM CARACTER ESPECIAL DE SINAL DE PORCENTAGEM NO COMEÇO E NO FINAL
SE NÃO TIVER O SINAL DE PORCENTAGEM, NÃO TEM COMO TRAZER O VALOR, POIS O TEXTO TEM DE COMEÇAR OU TERMINAR COM GMAIL
*/

select * FROM CLIENTES
WHERE Email LIKE '%GMAIL%' AND TELEFONE IS NULL;

SELECT * FROM CLIENTES
WHERE EMAIL LIKE '%.BR';


/*
IN OU NOT IN

ESSE COMANDO É UMA ALTERNATIVA PARA OS COMANDOS OR/AND
FILTRAM APENAS AS LINHAS COM UM DOS VALORES ESPECIFICADOS
-- WHERE COLUNA1 IN (VALOR1, VALOR2, VALOR3);
-- WHERE COLUNA1 = VALOR1 OR COLUNA1 = VALOR2....ETC. O COMANDO IN SIMPLIFICA ISSO
*/

SELECT * FROM PRODUTOS
WHERE MARCA_PRODUTO IN ('DELL', 'ALTURA', 'SONY');
-- WHERE MARCA_PRODUTO = 'DELL' OR MARCA_PRODUTO = 'ALTURA' OR MARCA_PRODUTO = 'SONY'

/*
 BETWEEN

PARA FILTRAR INTERVALOS DE NUMEROS OU DADOS
PRODUTOS COM PREÇOS ENTRE 10 E 100 REAIS
-- WHERE COLUNA1 BETWEEN VALOR1 AND VALOR2 (LEMBRANDO QUE AND DEIXA MAIS ESPECIFICO O FILTRO QUE OR)
*/
SELECT * FROM PRODUTOS
WHERE PRECO_UNIT BETWEEN 1000 AND 2000;
-- NA TABELA DE PRODUTOS DARIA PARA VERIFICAR ID_CATEGORIA, PRECO_UNIT, CUSTO_UNIT


/*
OPERAÇÕES BASICAS E DE ARREDONDAMENTO

PARA FAZER UMA SOMA BASTA USAR O + EXEMPLO: 10 + 20 AS 'SOMA'
PARA FAZER UMA DIMINUIÇÃO TEM O SINAL DE -
MULTIPLICAÇÃO É *
DIVISAO É A /
OPERAÇÕES SÃO FEITAS DETALHANDO EM COLCHETES O QUE FAZ PRIMEIRO (100 - 10) * 4
RESTO DA DIVISÃO É COM SINAL DE %
*/
SELECT
	10 + 20 	AS 'SOMA',
    100 - 40 	AS 'SUBTRAÇÃO',
    5 * 20 		AS 'MULTIPLICAÇÃO',
    300 / 12	AS 'DIVISÃO',
    (100 - 10) * 4 AS 'OPERAÇÃO',
    22 % 5 		AS 'RESTO DA DIVISÃO';

-- ARREDONDAMENTO
-- É FEITO COM ROUND (ARREDONDA DE ACORDO COM A MATEMATICA), CEILING (JOGA PARA CIMA), FLOOR (JOGA PARA BAIXO), TRUNCATE (ATÉ AS CASAS DECIMAIS QUE VOCÊ ESCOLHER
SELECT
	ROUND(87.149, 2) AS 'ARRED.',
    FLOOR(87.149)	 AS 'ARRED P/ BAIXO',
    CEILING(87.149)	 AS 'ARRED P/ CIMA',
	TRUNCATE(87.149, 1) AS 'TRUNCAR';	


-- COUNT (CONTAGEM), CONT DISTINC
-- COUNT (CONTAGEM) SERVE PARA CONTAR A QUANTIDADE DE ENTRADA
select * FROM CLIENTES;
SELECT
	COUNT(NOME) AS 'QTD CLIENTES' FROM CLIENTES WHERE SEXO = 'M';
SELECT
	count(TELEFONE) AS 'CONTATOS' FROM CLIENTES;
-- O COUNT * É PARA DEIXAR A CONSULTA MAIS GENERICA
SELECT
	count(*) FROM CLIENTES;
-- O COUNT DISTINTC VAI CONTAR A QUANTIDADE DE ENTRADAS DISTINTAS
-- EXEMPLO, NA TABELA PRODUTOS HÁ MARCAS DIFERENTES, COMO SABER QUANTO TEM DE CADA MARCA
SELECT
	COUNT(DISTINCT MARCA_PRODUTO) FROM PRODUTOS;
-- O RESULTADO 8 SÃO AS OITO MARCAS DISTINTAS


-- SUM (SOMA), AVG (MÉDIA), MIN (MÍNIMO) E MAX (MAXIMO)
SELECT * FROM PEDIDOS;
-- SUM (SOMA) VAI SOMAR OS VALORES DE UMA COLUNA
SELECT SUM(RECEITA_VENDA) AS 'RECEITA TOTAL' FROM PEDIDOS;
-- AVG (MEDIA) VAI DAR A MÉDIA DOS VALORES
SELECT avg(RENDA_ANUAL) AS 'MEDIA DE SALARIO' FROM CLIENTES;
-- MIN (MINIMO) VAI DAR O MINIMO DA COLUNA
SELECT MIN(PRECO_UNIT) AS 'PRECO UNITARIO MINIMO' FROM PRODUTOS;


/*
AGRUPAMENTOS

GROUP BY: PERMITE CRIAR AGRUPAMENTOS DAS TABELAS
BASICAMENTE CRIA UMA OUTRA TABELA AGRUPANDO INFORMAÇÕES QUE EU QUERO, RESUMINDO AS INFORMAÇÕES
*/
SELECT * FROM PRODUTOS;
SELECT MARCA_PRODUTO, COUNT(MARCA_PRODUTO) AS 'QTD. PRODUTOS'
FROM produtos
GROUP BY MARCA_PRODUTO;
-- SELECIONA A COLUNA (MARCA PRODUTO), FAZ UMA , E DAI FAZ O CALCULO (CONTAGEM, SOMA, ETC) E DAI FIZ UM AGRUPAMENTO PARA MOSTRAR EM UMA TABELA MENOR O RESULTADO

SELECT * FROM CLIENTES;
SELECT ESCOLARIDADE, COUNT(ESCOLARIDADE) AS 'CLIENTES'
FROM CLIENTES
GROUP BY ESCOLARIDADE;
-- NESTE OUTRO EXEMPLO, SELECIONAMOS A COLUNA QUE QUERIAMOS, CONTAMOS OUTRA COLUNA E DEPOIS AGRUPAMOS PELA COLUNA SELECIONADA

SELECT ID_LOJA, sum(RECEITA_VENDA) AS 'RECEITA TOTAL'
FROM PEDIDOS
GROUP BY ID_LOJA;
-- EXEMPLO DO TOTAL DE VENDAS POR ID DO PRODUTO

SELECT * FROM PEDIDOS;
SELECT ID_PRODUTO, SUM(CUSTO_VENDA) AS 'TOTAL RECEITA'
FROM PEDIDOS
GROUP BY ID_PRODUTO;

/*
GROUP BY + FILTRO WHERE

GROUP BY JUNTO COM O WHERE
WHERE É O COMANDO QUE PODE SER UTILIZADO COM O GROUP BY PARA QUE O O AGRUPAMENTO PROCURE INFORMAÇÕES APENAS ONDE O COMANDO WHERE APONTAR
*/
SELECT * FROM CLIENTES;
SELECT ESCOLARIDADE, count(*) AS 'QTD CLIENTES'
FROM CLIENTES
WHERE SEXO = 'F'
GROUP BY ESCOLARIDADE ;
-- O COMANDO WHERE É FEITO ANTES DO AGRUPAMENTO, ELE É UM FILTRO QUE AJUDA O AGRUPAMENTO A FUNCIONAR

/*
FILTRO HAVING
É UTILIZADO DEPOIS DO GROUP BY, DIFERENTE DO WHERE ELE CRIA O FILTRO DEPOIS DO AGRUPAMENTO
*/
select ESCOLARIDADE, COUNT(*) AS 'QTD CLIENTES'
FROM CLIENTES
GROUP BY ESCOLARIDADE
HAVING COUNT(*) > 25;
-- O EXEMPLO A SEGUIR É COM UM AGROUPAMENTO QUE VAI MOSTRAR A RECEITA TOTAL O SUPERIOR A 5 KK

SELECT * FROM PEDIDOS;
SELECT ID_PRODUTO, SUM(RECEITA_VENDA) AS 'RECEITA TOTAL'
FROM PEDIDOS
GROUP BY ID_PRODUTO
HAVING SUM(RECEITA_VENDA) >= 5000000;
-- LEMBRAR QUE O CALCULO TEM DE SER ESPECÍFICO


/*
VARIÁVEIS

É UM LOCAL ONDE SERÁ ARMEZENADO O VALOR QUE VAI SER UTILIZADO AO LONGO DO CÓDIGO
A IDEIA DA VARIAVEL É DEFINIR UMA EXPRESSÃO QUE IRÁ REPRESENTAR O QUE É VINCULADO A ELA, FACILITANDO O CÓDIGO

COMANDO SET NOMEDAVARIAVEL = 'O QUE QUER DEIXAR COMO VARIAVEL'

USER-DENIFED VARIABLES É O EXEMPLO ACIMA, COM O COMANDO SET
LOCAL VARIABLES QUE SÃO UTILIZADAS EM FUNÇÕES STORE PROCEDUES, ETC.

TODA VARIAVEL ARMAZENDA UM VALOR/DADO
INT (INTEIRO) / DECIMAL(M,D) D DIGITOS E M CASAS DECIMAIS/ FLOAT E VARCHAR (TEXTOS COM N CARACTERES) / DATE E DATETIME / ETC.

USER-DEFINIDED: ARMAZENA DADO PARA UTILIZAR NO CÓDIGO, FACILITANDO A UTILIZAÇÃO DELE. UTLIZAMOS O COMANDO SET
EXEMPLO DE CRIAÇÃO DE VARIAVEL
SET NOMEDAVARIAVEL = 'DADO ARMAZENADO';
*/

-- EXEMPLO PRATICO: UMA LOJA VENDEU 10 UNIDADES DE UM PRODUTO, PREÇO DE 10,90 CADA. CALCULE A RECEITA TOTAL GERADA NA VENDA COM VARIAVEL
SET @varQtd = 10;
SET @varPreco = 10.9;
SET @varReceita = @varQtd * @varPreco;

SELECT @varReceita AS 'RECEITA TOTAL';

-- EXEMPLO PRATICO 2
-- CRIAR CONSULTA A TABELA APENAS PARA PRODUTOS DA MARCA DELL COM VARIAVEIS
SET @VARMARCA = 'DELL';

SELECT *
FROM PRODUTOS
WHERE MARCA_PRODUTO = @VARMARCA;
-- BASTA ALTERAR O QUE ESTÁ NA VARIAVEL PARA PODER OBTER UM RESULTADO DIFERENTE


/* CAST

CONVERTE UM VALOR EM OUTRO TIPO
CONVERTE DECIMAL EM TIPO INTEIRO OU TEXTO POR EXEMPLO
NO CAST, INT É SIGNED OU UNSIGNED (SÓ POSITIVOS) E VARCHAR É CHAR
*/

SET @VARNUMERO = 10.9200;

SELECT @VARNUMERO,
	CAST(@VARNUMERO AS SIGNED),
    CAST(@VARNUMERO AS DECIMAL(10, 2)),
    CAST(@VARNUMERO AS CHAR(3));
    

/*
FUNÇÕES PARA MANIPULAR TEXTO

LENGHT
CONCAT E CONCAT_WS
LCASE (LOWER CASE - MINUSCULA) E UCASE (UPPER CASE - MAIUSCULA)
FUNÇÃO LEFT E RIGHT
REPLACE
INSTR E MID
DAY MONTH E YEAR
*/

-- LENGHT - RETORNA A QUANTIDADE DE CARACTERES
SET @VARCURSO = 'WAGNNER AUGUSTO';

SELECT length(@VARCURSO);
-- EXEMPLO COM BANCO DE DADOS
SELECT * FROM CLIENTES;
SELECT
	NOME AS 'NOME',
    length(NOME) AS 'CARACTERES'
FROM CLIENTES;


-- FUNÇÃO CONCAT E CONCAT_WS
-- FUNÇÃO PARA JUNTAR TEXTOS (CONCATENAR)
-- A CONCAT_WS PERMITE COLOCAR UM SEPARADOR ENTRE OS TEXTOS
-- PRECISA SÓ JUNTAR TEXTO, CONCAT, PRECISA COLOCAR SEPARADOR, COLOCAR CONCAT_WS
-- EXEMPLO
SET @varNome = 'Wagnner';
SET @varSobrenome = 'Augusto';
SET @varNomeCompleto = concat(@varNome, ' ', @varSobrenome);
SET @varNomeDenovo = concat_ws(' - ', @varNome, @varSobrenome);

SELECT @varNomeDenovo;  
-- EXEMPLO DOIS, COM BANCO DE DADOS
SELECT * FROM CLIENTES;
SELECT
	ID_CLIENTE,
    NOME,
    SOBRENOME,
    concat_ws(' ', NOME, SOBRENOME) AS 'NOME COMPLETO',
    EMAIL
FROM clientes;


-- LCASE (LOWER CASE - MINUSCULA) E UCASE (UPPER CASE - MAIUSCULA)
-- UM EXEMPLO SERIA DEFINIR A VARIAVEL E QUANDO FOR DAR UM SELECT NELA COLOCAR O LCASE OU UCASE ANTES.
-- UTILIZANDO O EXEMPLO ANTERIOR
SELECT
	LCASE(concat(NOME, ' ', SOBRENOME)) AS 'NOME COMPLETO 01',
    UCASE(concat_ws(' ', NOME, SOBRENOME)) AS 'NOME COMPLETO 02'
FROM clientes;


-- FUNÇÃO LEFT E RIGHT
-- EXTRAI TEXTO MAIS A ESQUEDA (LEFT) OU A DIREITA (RIGHT)
-- EXEMPLO
SET @var = 'SQL Wagnner';

SELECT
	LEFT(@var, 3) AS 'L',
    RIGHT(@Var, 7) AS 'R';
    

-- FUNÇÃO REPLACE
-- SUBSTITUI TEXTOS
SET @texto = 'Wagnner está aprendendo SQL';
SET @textonovo = REPLACE(@texto, 'Wagnner', 'Augusto');
select @texto, @textonovo;
-- EM QUERIES O REPLACE É UTILIZADO APÓS A LINHA ONDE QUER SUBSTITUIR O TEXTO
SELECT
	NOME,
    ESTADO_CIVIL,
    REPLACE(ESTADO_CIVIL, 'S', 'SOLTEIRO')
FROM CLIENTES;
-- PARA ADICIONAR DOIS REPLACES, TEM DE FAZER UM DENTRO DO OUTRO
SELECT
	NOME,
    ESTADO_CIVIL,
    REPLACE(REPLACE(ESTADO_CIVIL, 'S', 'SOLTEIRO'), 'C', 'CASADO')
FROM CLIENTES;


/*INSTR E MID
INSTR RETORNA A POSIÇÃO DE UM CARACTERE
MID EXTRAI TEXTOS DE FORMA PERSONALISADA DE ACORDO COM A POSIÇÃO INICIAL
*/

-- EXEMPLOS
-- RETORNAR POSIÇÃO DO @ NO EMAIL
-- RETORNAR O ID DO EMAIL

SET @VAREMAIL = 'WAGNNER@GMAIL.COM';
-- POSIÇÃO DO @
SET @VARPOSIARROBA = instr(@VAREMAIL, '@');
SELECT @VARPOSIARROBA;
-- O ID DO EMAIL (ANTES DO @)
-- PRIMEIRO DA PARA RESOLVER COM A FUNÇÃO LEFT, CRIASE OUTRA VARIAVEL E UTILIZA A FUNÇÃO LEFT NELA POR EXEMPLO
SET @VARID = LEFT(@VAREMAIL, 7);
SELECT @VARID;
-- SÓ QUE A FUNÇÃO LEDT SEMPRE COMEÇA PESQUISANDO DA ESQUERDA, A FUNÇÃO MID TE PERMITE PROCURAR EM TODO O TEXTO
SET @VARSERVER = MID(@VAREMAIL, 9, 5);

SELECT @VARSERVER;
-- A FUNÇÃO MID PEDE TRES VALORES, ONDE SERÁ FEITA A CONSULTA, A POSIÇÃO QUE COMEÇA E A QUE TERMINA
-- COMO ESTAMOS TRABALHANDO COM VARIAVEIS, O PRIMEIRO VALOR QUE FOI NO MID FOI A VARIAVEL ONDE EU QUIS PESQUISAR
-- PARA DEIXAR MAIS AUTOMATICO, PODEMOS UTILIZAR O INSTR EM UMA VARIAVEL PARA ACHAR A POSIÇÃO DO ARROBA E DAI A VARIAVEL MID TERÁ ESSA VARIAVEL COMO FINAL -1. O -1 É PARA NÃO PUXAR O ARROBA
SET @EMAIL = 'WAGNNERAUGUSTO_APRENDENDO@GMAIL.COM';
SET @POSICAO = instr(@EMAIL, '@');
SET @IDEMAIL = mid(@EMAIL, 1, @POSICAO - 1);
SELECT @IDEMAIL;
-- EXEMPLO PRATICO COM BANCO DE DADOS
SELECT * FROM CLIENTES;
SELECT
	EMAIL,
    MID(EMAIL, 1, instr(EMAIL, '@') -1)
FROM CLIENTES;
-- SEM UTILIZAR VARIAVEIS, PRIMEIRO USAMOS MID E DENTRO DELE USAMOS O INSTR, ASSIM COMO O REPLACE DENTRO DO REPLACE. ISSO É COMBINAÇÃO DE FUNÇÕES


-- DAY MONTH E YEAR
SELECT * FROM CLIENTES;
SELECT
	NOME,
    DATA_NASCIMENTO,
    DAY(DATA_NASCIMENTO) AS 'DIA',
    MONTH(DATA_NASCIMENTO) AS 'MES',
    YEAR(DATA_NASCIMENTO) AS 'ANO'
FROM CLIENTES;

-- NOW, CURDATE(DATA ATUAL) E CURTIME(HORA ATUAL)
SELECT
	NOW() AS 'DATA E HORA',
    CURDATE() AS 'HOJE',
    curtime() AS 'HORA';
-- DATEDIFF CALCULA E DIFERENÇA DE DATAS, BOM PARA CALCULAR O QUANTO FALTA DE ALGO OU TEMPO QUE DUROU ALGO
SELECT datediff('DATA 01', 'DATA 02');
-- DATA_ADD ADICIONA UMA QUANTIDADE A UMA DETERMINADA DATA
-- EM UM EXEMPLO DE UM PROJETO QUE TEM DE SER ENTREGUE E TANTOS DIAS APÓS O INICIO
SELECT date_add('2024/10/07', INTERVAL 10 DAY);
-- DATA_SUB


/*
JOINS - RELACIONAMENTO DE TABELAS

--CHAVES PRIMARIAS E ESTRANGEIRAS
ESSE COMANDO VAI RELACIONAR TABELAS, OU SEJA, SERÁ POSSÍVEL FAZER PESQUISAR TRAZENDO RESULTADOS EM VÁRIAS TABELAS

A CHAVE PRIMARIA É UMA COLUNA QUE IDENTIFICA AS INFORMAÇÕES DISTINTAS DAQUELA TABELA NÃO TENDO VALORES REPITIDOS. GERALMENTE É A COLUNA DE ID, ELA IDENTIFICA CADA LINHA DA TABELA
A CHAVE ESTRANGEIRA É A QUE PERMITE RELACIONAR AS TABELAS. NESSA CHAVE, OS ITENS PODEM SE REPETIR

EXEMPLO: EM UMA TABELA DE PRODUTOS, CADA PRODUTO TEM UM ID, QUE SERVE PARA IDENTIFICAR ELES, JÁ NA TABELA DE PEDIDOS, A COLUNA DE ID DO PRODUTO SERVE PARA DIZER QUANTAS VEZES ELE FOI VENDIDO...
...SENDO ASSIM, OS VALORES PODEM SE REPETIR, SENDO ASSIM UMA CHAVE ESTRANGEIRA

-- TABELA FATO E TABELÇA DIMENSÃO
DIMENSÃO É A TABELA QUE TEM AS CARACTERISTICAS DO ELEMENTO, GERALMENTE ONDE SE ENCONTRAM AS CHAVES PRIMARIAS, COMO A TABELA DE PRODUTOS
FATO É A TABELA QUE VAI REGISTRAR OS ACONTECIMENTOS DE UMA EMPRESA EM UM DETERMINADO PERIODO DE TEMPO, COMO VENDAS, DEVOLUÇÕES, CONTRATOS, ETC. GERALMENTE NESSAS TABELAS QUE APARECEM AS CHAVES ESTRANGEIRAS

A LÓGICA DOS JOINS VAI SER TRAZER RESULTADOS JUNTANDO INFORMAÇÕES DE TABELAS DIFERENTES, PELO COMANDO JOIN
EXISTEM VÁRIOS JOINS, LEFT, RIGHT, INNER E FULL
SELECT 
	Tabela_A.coluna1,
	Tabela_A.coluna2,
    Tabela_A.coluna3
FROM
	Tabela_A
INNER JOIN Tabela_B
	ON Tabela_A.id_chave_estrangeira = Tabela_B.id_chave_primaria;

PRIMEIRO É SELECIONADOS AS COLUNAS QUE QUEREMOS QUE SEJA RETORNADO NA CONSULTA DA TABELA QUE QUEREMOS COMPLEMENTAR, DEPOIS COLOCAMOS O COMANDO INNER JOIN E SELECIONAMOS A TABELA QUE TEM AS INFOS QUE FALTAM
DEPOIS COLOCAMOS O COMANDO ON E DEPOIS TERMINAMOS COLOCANDO AS CHAVES QUE AMBOS TEM EM COMUM
*/

-- EXEMPLO PRATICO DE CONSULTA QUE RELACIONA PEDIDOS COM PRODUTOS
-- 01 IDENTIFICA-SE QUAL É A TABELA FATO E QUAL É A TABELA DIMENSÃO: FATO = PEDIDOS - DIMENSÃO = PRODUTOS
-- 02 IDENTIFICA-SE A CHAVE PRIMARIA E A ESTRANGEIRA: ID_PRODUTO É PRIMARIA NA TABELA PRODUTO E ESTRANGEIRA NA TABELA PEDIDOS
-- 03 QUAIS COLUNAS TRAZER: DO PEDIDOS - ID_PEDIDO, DATA_VENDA, ID_PRODUTO, QTD_VENDIDA, RECEITA_VENDA
-- 04 QUAIS COLUNAS TRAZER: DO PRODUTOS - NOME_PRODUTO, MARCA_PRODUTO
SELECT * FROM PRODUTOS;
SELECT * FROM PEDIDOS;
SELECT
	pedidos.ID_PEDIDO,
    pedidos.DATA_VENDA,
    pedidos.ID_PRODUTO,
    pedidos.QTD_VENDIDA,
    pedidos.RECEITA_VENDA,
    produtos.NOME_PRODUTO,
    produtos.MARCA_PRODUTO
FROM 
	pedidos
INNER JOIN produtos
	ON pedidos.ID_Produto = produtos.ID_Produto;
-- SELECIONA TODAS AS COLUNAS QUE VOCÊ QUER VER DAS DUAS TABELAS COMO SE FOSSE UMA CONSULTA SIMPLES, IDENTIFICANDO DE QUAL TABELA É CADA COLUNA
-- O INNER JOIN TA ALI SÓ PARA RELACIONAR AS TABELAS (FAZER A LIGAÇÃO) E PERMITIR QUE A CONSULTA TRAGA OS RESULTADOS, É APENAS A CONEXÃO EM COMUM ENTRE AS TABELAS QUE PERMITE O SGBD A IR BUSCAR AS INFORMAÇÕES

-- EXEMPLO PRATICO 2, RELACIONAR CLIENTES, PEDIDOS E PRODUTOS
SELECT * FROM CLIENTES;
SELECT * FROM PEDIDOS;
SELECT * FROM PRODUTOS;
-- FATO PEDIDOS - DIMENSÃO CLIENTES
-- CHAVE PRIMARIA ID CLIENTES NO CLIENTES E ESTRANGEIRA NO PEDIDOS (DESCOBRIR O QUE LIGA AS TABELAS)
-- CHAVE PRIMARIA ID PRODUTOS NO PRODUTOS E ESTRANGEIRA NO PEDIDOS (DESCOBRIR O QUE LIGA AS TABELAS)
-- COLUNAS DO PEDIDOS ID_PEDIDO, DATA_VENDA, ID_PRODUTO, QTD_VENDIDA, ID_CLIENTE
-- COLUNAS DO CLIENTES NOME, SOBRENOME, SEXO, EMAIL
-- COLUNAS DO PRODUTOS NOME_PRODUTO, MARCA_PRODUTO

SELECT
	pedidos.ID_Pedido,
    pedidos.Data_Venda,
    pedidos.ID_Produto,
    pedidos.Qtd_Vendida,
    pedidos.ID_Cliente,
    clientes.Nome,
    clientes.Sobrenome,
    clientes.Sexo,
    clientes.Email,
    produtos.Nome_Produto,
    produtos.Marca_Produto
FROM pedidos
INNER JOIN clientes
	ON pedidos.ID_Cliente = clientes.ID_Cliente
INNER JOIN produtos
	ON pedidos.ID_Produto = produtos.ID_Produto;

-- NÃO É NECESSÁRIO COLOCAR O NOME DA TABELA NA FRENTE DA COLUNA, A NÃO SER QUE SEJAM DUPLICADAS (CHAVE ESTRANGEIRAS), DAI TEM DE COLOCAR
-- BOA PRÁTICA É COLOCAR O NOME DA TABELA NA FRENTE SEMPRE PARA NÃO TER ERRO
-- É POSSÍVEL DAR NOMES AS TABELAS COLOCANDO O COMANDO AS APÓS O NOME DA TABELA NA CONSULTA, E DIMINUI TAMBÉM A INFORMAÇÃO QUE VOCÊ PRECISA COLOCAR
SELECT
	P.ID_Pedido,
    P.Data_Venda,
    P.ID_Produto,
    P.Qtd_Vendida,
    P.ID_Cliente,
    C.Nome,
    C.Sobrenome,
    C.Sexo,
    C.Email
FROM pedidos AS P
INNER JOIN clientes AS C
	ON P.ID_Cliente = C.ID_Cliente;
    
-- É POSSIVEL APLICAR FILTROS E AGRUPAMENTOS JUNTO COM O INNER JOIN
-- O JOIN GANHAM NA PRIORIDADE DE CÓDIGOS, SENDO ASIM, O WHERE TEM DE VIR DEPOIS DO JOIN, PARA QUE O SQL SAIBA ONDE BUSCAR A INFORMAÇÃO
SELECT
	P.ID_Pedido,
    P.Data_Venda,
    P.ID_Produto,
    P.Qtd_Vendida,
    P.ID_Cliente,
    C.Nome,
    C.Sobrenome,
    C.Sexo,
    C.Email
FROM pedidos AS P
INNER JOIN clientes AS C
	ON P.ID_Cliente = C.ID_Cliente
WHERE Sexo = 'M'
LIMIT 20;

-- OS AGRUPAMENTOS VÃO OCORRER DEPOIS DO JOIN
SELECT
	NOME_PRODUTO,
    sum(RECEITA_VENDA) AS 'RECEITA TOTAL'
FROM PEDIDOS
INNER JOIN PRODUTOS
	ON pedidos.ID_Produto = produtos.ID_Produto
group by NOME_PRODUTO;
-- O INNER JOIN AQUI FOI UTLIZADO PARA TRAZER O NOME DO PRODUTO E O AGRUPAMENTO ACONTECE DEPOIS PQ O INNER JOIN TEM PRIORIDADE

-- EXEMPLO PARA MOSTRAR O TOTAL DE RECEITA E CUSTO POR ID DA LOJA, TROCANDO O ID PELO NOME PELO INNER JOIN
SELECT * FROM PEDIDOS;
SELECT * FROM LOJAS;

SELECT
	Loja,
	sum(Receita_Venda) as 'Receita',
    sum(Custo_Venda) as 'Custo'
FROM pedidos
INNER JOIN lojas
	ON pedidos.ID_Loja = lojas.ID_Loja
group by Loja ASC;
-- AS FUNÇÕES SÃO UTILIZADAS UMA DE CADA VEZ
-- O INNER JOIN POSSIBILITA COLCOAR O NOME DA LOJA
-- O GROUP BY TRAZ ONDE ESSES CALCULOS APARECEM


/* FUNÇÕES CONDICIONANTES
IF
IFNULL, ISNULL, E NULLIF
CASE-THEN
*/

/*
IF (SE)

ELA PEDE TRÊS ARGUMENTOS: TESTE LOGICO, SE VERDADEIRO, SE FALSO
IF(TESTE_LOGICO1, VALOR_SE_VDD, IF(TESTE2, VALOR_SE_VDD2, VALOR_SE_FALSO)))
*/
SELECT
	IF (10 > 5 , 'VDD', 'FAKE') AS 'TESTE 01',
	IF (20 < 10, 'VDD', 'FAKE') AS 'TESTE 02';

-- EXEMPLO PRATICO 02
-- DESCOBRIR SE OS FUNCIONARIOS QUE TIVERAM AVALIAÇÃO DO RH RECEBEM BONUS
SET @VARNOTA = 8.5;
SELECT
	IF(@VARNOTA >= 7, 0.1, 'SEM BONUS');

-- SE TIVESEM MAIS CRITÉRIOS
SET @VARNOTA = 6;
SELECT
	IF(@VARNOTA >= 7, 0.1, IF(@VARNOTA >= 5, 0.05, 'SEM BONUS'));

-- APLICANDO EM UM CASO PRATICO
-- LOJAS QUE TEM MAIS DE 20 FUNCIONARIOS RECEBEM UMA REFORMA DE AMPLIAÇÃO
SELECT * FROM LOJAS;
SELECT
	*,
    IF(NUM_FUNCIONARIOS >= 20, 'COM REFORMA', 'SEM REFORMA') AS 'STATUS'
FROM LOJAS;
-- A FUNÇÃO CONIDICONAL CRIA UMA COLUNA NOVA COM A CONDIÇÃO APLICADA


/*
IFNULL, ISNULL, E NULLIF

IFNULL RETORNA UMA ALTERNATIVA AO QUE SEJA NULL
SELECT
	ifnull(NULL, 'VALOR ALTERNATIVO');
*/

-- EXEMPLO PRATICO, LOJAS SEM TELEFONE, AJUSTAR PARA UM PADRÃO
SELECT * FROM LOJAS;
SELECT
	*,
    ifnull(telefone, '0800-000-000')
FROM LOJAS;
-- NESSE CASO SELECIONAMOS A PLANILHA TODA, SÓ CORRIGIMOS A INFO DO TELEFONE

-- ISNULL
-- VAI IDENTIFICAR SE O VALOR É NULO, SE NULO RETORNA 1, SE NÃO RETORNA 0
SELECT
	*,
    ISNULL(TELEFONE) AS 'CHECK'
FROM CLIENTES;
-- DA PARA AUMENTAR A FUNÇÃO E COLOCAR INFORMAÇÕES
SELECT
	*,
    IF(ISNULL(TELEFONE), 'VERIFICAR', 'OK') AS 'STATUS'
FROM CLIENTES;

-- NULLIF
-- VAI COMPARAR DUAS EXPRESSOES. SE IGUAIS, RETORNA NULL, SE DIFERENTES, RETORNA A PRIMEIRA EXPRESSÃO
SET @VAR1 = 500;
SET @VAR2 = 500; 
SELECT
	NULLIF(@VAR1, @VAR2);


/*
CASE-THEN

FUNÇÃO QUE TRAZ OPÇÕES DE CONDICIONANTES PARA RETORNAR UM RESULTADO
 
CASE
	WHEN CONDIÇÃO THEN RESULTADO1
    WHEN CONDIÇÃO THEN RESULTADO2
    WHEN CONDIÇÃO THEN RESULTADO3
    ELSE RESULTADO4
END

O CASE EXECUTA DA PRIMEIRA LINHA ATÉ A ULTIMA, SE A PRIMEIRA LINHA N ATENDE AOS REQUISITOS, VAI PARA SEGUNDA, ETC.
*/

/*
CASE-AND/OR

AND E OR SERÃO APLICADOS DENTRO DAS CONDIÇÕES, DEIXANDO AINDA MAIS ESPECIFICA AS CONDIÇÕES QUE DEVEM SER ALCANÇADAS

CASE
		WHEN CONDIÇÃO1 AND CONDIÇÕES2 THEN RESULTADO1
        WHEN CONDIÇÃO3 OR CONDIÇÃO4 THEN RESULTADO2
        WHEN CONDIÇÃO5 THEN RESULTADO3
        ELSE RESULTADO4
END
*/

-- EXEMPLO PRATICO - VER SE OS CLIENTES VÃO RECEBER BRINDES
 SELECT
	*,
    CASE
		WHEN SEXO = 'F' AND QTD_FILHOS > 0 THEN 'GANHA BRINDE DE DIA DAS MÃES'
        WHEN SEXO = 'M' AND QTD_FILHOS > 0 THEN 'GANHA BRINDE DE DIA DOS PAIS'
        ELSE 'SEM OFERTA'
	END AS 'CONDIÇÕES'
FROM CLIENTES;

-- EXEMPLO PRATICO 02
-- DESCONTO DAS MARCAS DELL E SAMSUNG DE 15% NO CUSTO_UNMIT
-- PARA CACULAR JA O VALOR COM DESCONTO, PODE COLOCAR O CALCULO NO THEN
SELECT
	*,
    CASE
		WHEN MARCA_PRODUTO = 'DELL' OR MARCA_PRODUTO = 'SAMSUNG' THEN (1 - 0.15) * CUSTO_UNIT
        ELSE 'SEM DESCONTO'
	END AS 'TEM DESCONTO?'
FROM PRODUTOS;

-- OUTRA ALTERNATIVA PARA TORNAR O CÓDIGO AINDA MENOR, SERIA USAR O COMANDO IN
SELECT
	*,
    CASE
		WHEN MARCA_PRODUTO IN('DELL', 'SAMSUNG', 'SONY') THEN (1 - 0.15) * CUSTO_UNIT
        ELSE 'SEM DESCONTO'
	END AS 'TEM DESCONTO?'
FROM PRODUTOS;


/*
VIEWS

AS TABELAS RESULTADOS DE SELECT DO SQL NÃO ESTÃO ARMAZENADAS EM UM LUGAR ESPECÍFICO, UM NOVO SELECT ANULA O OUTRO
A VIEW É UMA TABELA VIRTUAL DE UMA CONSULTA A UMA OU MAIS TABELAS DO DATA BASE, OU SEJA, É UMA FORMA DIFERENTE DE ARMAZENAR A CONSULTA
ALTEROU O DATA BASE, É POSSÍVEL ALTERAR A VIEW, E NELA DA PARA USAR COMANDOS COMO WHERE, JOIN, ETC.
REUTILIZAÇÃO, SEGURANÇA E TEMPO OTIMIZADO SÃO AS VANTAGENS
A VIEW APARECE ABAIXO DO DATA BASE
*/
 
-- CRIANDO / ALTERANDO E EXCLUINDO A VIEW
-- CRIAR
CREATE VIEW vclientes AS
SELECT
	ID_Cliente,
    Nome,
    Data_Nascimento,
    Email,
    Telefone
FROM clientes;
select * from vclientes;

-- OUTRO EXEMPLO
SELECT
	ID_Cliente,
    Nome,
    Data_Nascimento,
    Email,
    Telefone
FROM clientes;
select * from vclientes
where Email like '%GMAIL%';

-- ALTERAR
alter view vclientes as
select
	ID_Cliente,
    Nome,
    Email,
    Telefone,
    Escolaridade
from clientes
where Escolaridade = 'Parcial';
select * from vclientes;
-- CLICAR COM O BOTAO DIREITO NA VIEW E IR EM ALTER VIEW, APARECE O CÓDIGO ORIGINAL QUE CRIOU ELA

-- EXCLUIR
-- PODE USAR DOIS COMANDOS, OU CLICAR EM DROP (BOTÃO DIREITO) OU VIR NO CÓDIGO MESMO E ESCREVER O COMANDO DROP VIEW

-- OUTROS EXEMPLOS
CREATE VIEW VPEDIDOS AS
SELECT
	pedidos.ID_Pedido,
    pedidos.Data_Venda,
    lojas.Loja,
    produtos.Nome_Produto,
    produtos.Marca_Produto,
    pedidos.Qtd_Vendida,
    pedidos.Preco_Unit,
    pedidos.Receita_Venda,
    clientes.Nome,
    clientes.Sexo,
    clientes.Email
FROM pedidos
INNER JOIN lojas
	ON pedidos.ID_Loja = lojas.ID_Loja
INNER JOIN produtos
	ON pedidos.ID_Produto = produtos.ID_Produto
INNER JOIN clientes
	ON pedidos.ID_Cliente = clientes.ID_Cliente;
select * from vpedidos;

alter view vpedidos as
SELECT
	pedidos.ID_Pedido,
    pedidos.Data_Venda,
    lojas.Loja,
    produtos.Nome_Produto,
    produtos.Marca_Produto,
    pedidos.Qtd_Vendida,
    pedidos.Preco_Unit,
    pedidos.Receita_Venda,
    clientes.Nome,
    clientes.Sexo,
    clientes.Email
FROM pedidos
INNER JOIN lojas
	ON pedidos.ID_Loja = lojas.ID_Loja
INNER JOIN produtos
	ON pedidos.ID_Produto = produtos.ID_Produto
INNER JOIN clientes
	ON pedidos.ID_Cliente = clientes.ID_Cliente
WHERE pedidos.Preco_Unit >= 2000;

select * from vpedidos;

-- OUTRO EXEMPLO PRATICO
ALTER VIEW vReceita AS
SELECT
	P.ID_Produto,
	PR.Nome_Produto,
    PR.Marca_Produto,
    sum(P.Custo_Venda) AS 'Total Custo',
    sum(P.Receita_Venda) AS 'Receita Total'
FROM pedidos AS P
INNER JOIN produtos AS PR
	ON P.ID_Produto = PR.ID_Produto
WHERE P.ID_Loja = 2
GROUP BY P.ID_Produto, PR.Nome_Produto, PR.Marca_Produto
HAVING sum(P.Receita_Venda) >= 1000000;
SELECT * FROM vreceita;
/*
SE O CÓDIGO ESTÁ ERRADO, A VIEW É CRIADA MAS NÃO APARECE EM CONSULTA.
É PRECISO ALTERAR PARA QUE ELA APAREÇA.
O CÓDIGO ESTAVA ERRADO POIS ORIGINALMENTE NÃO TINHA INCLUIDO O NOME_PRODUTO E MARCA_PRODUTO NO GROUP BY, E COMO NÃO TINHA FUNÇÃO AGREGADA, PRECISAVA SER INCLUIDO
PODIA TAMBÉM PERSONALIZAR AINDA MAIS COLOCANDO UM HAVING NO FINAL DA VIEW, LIMITANDO OS VALORES DA SOMA
*/


/*
OPERAÇÕES CRUD
-- C - CREATE
-- R - READ
-- U - UPDATE
-- D - DELETE
SÃO OPERAÇÕES DIRETAS PARA BANCO DE DADOS
*/

/*
CREATE DATABASE

COMANDO CREATE DATABASE NOME_DB;
VARIAÇÃO CREATE DATABASE IF NOT EXISTS NOME_DB;
PARA VERIFICAR QUAIS BANCOS DE DADOS EXISTEM, TEM O COMANDO "SHOW DATABASES";
*/
CREATE DATABASE DB_EXEMPLO;

-- JÁ O COMANDO "USE" DEFINE QUAL O BANCO DE DADOS PADRÃO A SER UTILIZADO;
-- O COMANDO "DROP DATABASE" OU "DROP DATABASE IF NOT EXISTS" PODEM SER USADOS PARA DELETAR BANCO DE DADOS;

-- CRIANDO TABELAS NOS BANCO DE DADOS
USE DB_EXEMPLO;
/*
TEM DE ESPECIFICAR QUANTAS COLUNAS O BANCO DE DADOS TERÁ
RELEMBRANDO QUE INT VAI SER NUMERO INTEIRO
DECIMAL É ESPECIFICADO NAS QUANTIDADES DE DIGITOS E CASAS DECIMAIS. 100,59 (5 DIGITOS QUE É O M E 2 CASAS DECIMAIS)
VARCHAR SÃO TEXTOS, SENDO QUE 'N' PODE DETERMINAR QUANTOS CARACTERES TERÃO NO MAXIMO
*/

-- EXEMPLO
CREATE TABLE IF NOT EXISTS dAlunos(
	ID_Aluno INT,
    Nome_Aluno varchar(100),
    Email varchar(100)
);

CREATE TABLE IF NOT EXISTS dCursos(
	ID_Curso INT,
    Nome_Curso varchar(100),
    Preco_Curso varchar(100)
);

CREATE TABLE IF NOT EXISTS dMatriculas(
	ID_Aluno INT,
    ID_Curso INT,
    Data_Cadastro date
);

-- PARA ALTERAR, UTILIZA-SE O COMANDO ALTER TABLE + NOME DA TABELA MODIFY COLUMN + NOME DA COLUNA + O QUE VAI SER ALTERADO
alter table dCursos
modify column Preco_Curso decimal(10, 2);

-- para excluir a tabela, comando "drop table"
SHOW TABLES;

drop table dAlunos;
drop table dMatriculas;
drop table dCursos;


/*
CONSTRAINS

SÃO RESTRIÇÕES QUE PODEM SER APLICADAS AS COLUNAS, IMPEDINDO PROBLEMAS NA CRIAÇÃO DAS TABELAS
-- NOT NULL: NÃO ACEITA VALORES NULL (NULL É DIFERENTE DE ZERO)
-- UNIQUE: GARANTE REGISTRO UNICO NA COLUNA
-- PRIMARY KEY: DIZ QUE TAL COLUNA É UMA CHAVE PRIMARIA, DETERMINANDO ELA COMO UNICA
-- FOREGING KEY: IDENTIFICA QUAL COLUNA PODE SER RELACIONADA NA TABELA FATO
-- DEFAULT: SE NÃO TIVER NENHUM VALOR INSERIDO, FICA UM VALOR PADRÃO
*/

CREATE table IF NOT EXISTS dAlunos(
	ID_Aluno INT,
    Nome_Aluno varchar(100) NOT NULL,
    Email varchar(100) NOT NULL,
    primary key(ID_Aluno)
);

CREATE table IF NOT EXISTS dCursos(
	ID_Curso INT,
    Nome_Curso varchar(100) NOT NULL,
    Preco_Curso decimal(10, 2) NOT NULL,
    primary key(ID_Curso)
);

CREATE table IF NOT EXISTS dMatriculas(
	ID_Matricula INT NOT NULL,
	ID_Aluno INT NOT NULL,
    ID_Curso INT NOT NULL,
    Data_Cadastro date NOT NULL,
    primary key(ID_Matricula),
    foreign key(ID_Aluno) references dAlunos(ID_Aluno),
    foreign key(ID_Curso) references dCursos(ID_Curso)
);

-- INSERIR DADOS NA TABELAS
-- O COMANDO UTILIZADO É O "INSET INTO"

INSERT INTO dAlunos(ID_Aluno, Nome_Aluno, Email)
values
	(1, 'WAGNNER', 'WAGNNER123@GMAIL.COM'	),
    (2, 'FERNANDO', 'FERNANO123@GMAIL.COM'	),
    (3, 'CARMEN', ' CARMEN123@HOTMAIL.COM'	),
	(4, 'LUIZ', 'LUIZ123@ICLOUD.COM'		);
SELECT * FROM DALUNOS;

-- PARA ATUALIZAR AS TABELAS, UTILIZAM-SE OS COMANDOS UPDATE
UPDATE DALUNOS
SET EMAIL = 'LUIZ123@HOTMAIL.COM'
WHERE ID_ALUNO = 4;
-- É SEMPRE POR PARTES: UPDATE QUAL TABELA - SET O QUE VAI SER ATUALIZADO EM QUAL COLUNA - WHERE EM QUAL LINHA ESTÁ A INFO QUE VAI SER ATUALIZADA.

-- DELETAR REGISTROS OCORRE COM O COMANDO DELETE
DELETE FROM DALUNOS
WHERE ID_ALUNO = 1;
-- ESSE COMANDO DELETOU A LINHA DE ACORDO COM O ID UM DA TABELA
-- PARA TIRAR INFOS DA TABELA, APENAS UTILIZAMOS O COMANDO UPDATE, QUE TROCA AS INFOS SEM DELETAR LINHA

-- TRUNCATE TABLE:
-- DELETA OS REGISTROS, MAS A TABELA CONTINUA EXISTINDO

-- DROP TABLE: DELETA A TABELA EM SI, NÃO SOBRA NADA

/* Chaves Estrangeiras (Foreign Keys): Se a tabela que você está tentando excluir tem chaves estrangeiras associadas a ela
	(ou se outras tabelas têm chaves estrangeiras que dependem da tabela que você está tentando excluir)
	o comando DROP TABLE falhará. Nesse caso, você precisaria remover as chaves estrangeiras antes de excluir a tabela
    IDENTIFIQUE AS CHAVES ESTRANGEIRAS, DEPOIS REMOVER ELAS, DAI EXCLUIR OU TRUNCAR A TABELA
    */
DROP TABLE DMATRICULAS;
TRUNCATE TABLE DALUNOS;


-- FUNCTIONS
-- É UMA ROTINA, UM CONJUNTO DE INSTRUÇÕES QUE PODEMOS SALVAR NO DB SEM PRECISAR FICAR RECRIANDO ELES

/*
DELIMITER $$

CREATE FUNCTION NOME_FUNÇÃO(PARMETRO01 TIPO01, PARAMETRO02 TIPO02)
RETURNS TIPO DETERMINISTIC
BEGIN
	INSTRUÇÕES1;
    INSTRUÇÕES2;
    INSTRUÇÕES3;
    RETURN EXPRESSÃO
END $$

DEMILITER ;

O DELIMITER PERMITE QUE O SQL VÁ ALÉM DO PONTO E VIRGULA QUE TEM NO CÓDIGO. VAI DO $$ ATÉ O OUTRO $$
A FUNCTION BASICAMENTE PEDE VALORES COMO ARGUMENTOS E RETORNA O QUE É PEDIDO

*/

-- EXEMPLO PRATICOS
-- CRIAR UMA FUNCTION PARA DIZER OLÁ MUNDO!
DELIMITER $$
CREATE FUNCTION FN_HW(NOME VARCHAR(100))
RETURNS VARCHAR(100) DETERMINISTIC
BEGIN
	RETURN CONCAT('HELLO', NOME, 'WHATS UP?');
END $$
DELIMITER ;

SELECT FN_HW('WAGNNER');

-- EXEMPLO 2 CALCULA DE PREÇO TOTAL POR QUANTIDADE
DELIMITER $$

CREATE FUNCTION fn_faturamento(preco DECIMAL(10, 2), quantidade INT)
RETURNS DECIMAL(10, 2) DETERMINISTIC
BEGIN
	RETURN preco * quantidade;
END $$

DELIMITER ;

SELECT FN_FATURAMENTO(10.99, 100);
-- ESSA FUNCTION MULTIPLICA O PREÇO UNITÁRIO PELA QUANTIDADE PARA RETORNAR O FATURAMENTO TOTAL DA VENDA

-- EXEMPLO 3 FUNÇÃO QUE SUBSTITUA OS CARACTERES COM ACENTOS POR SEM ACENTOS
DELIMITER $$
CREATE FUNCTION FN_ACENTOS(TEXTO VARCHAR(100))
RETURNS VARCHAR(100) DETERMINISTIC
BEGIN
	SET TEXTO = REPLACE(TEXTO, 'á', 'a'),
		TEXTO = REPLACE(TEXTO, 'é', 'e'),
        TEXTO = REPLACE(TEXTO, 'í', 'i'),
        TEXTO = REPLACE(TEXTO, 'ó', 'o'),
        TEXTO = REPLACE(TEXTO, 'ú', 'u'),
        TEXTO = REPLACE(TEXTO, 'à', 'a'),
        TEXTO = REPLACE(TEXTO, 'è', 'e'),
        TEXTO = REPLACE(TEXTO, 'ì', 'i'),
        TEXTO = REPLACE(TEXTO, 'ò', 'o'),
        TEXTO = REPLACE(TEXTO, 'ù', 'u'),
        TEXTO = REPLACE(TEXTO, 'ç', 'c');
        RETURN TEXTO;
END $$
DELIMITER ;

SELECT
	Loja,
    Endereco,
    FN_ACENTOS(Endereco)
FROM lojas;
-- TEM DE COLOCAR QUAIS COLUNAR QUER QUE A FUNÇÃO FUNCIONE
    
-- ALTER FUNCTION
-- PARA ALTERAR, CLICA COM O BOTÃO DO MOUSE EM CIMA DA FUNÇÃO E CLICA EM ALTER FUNCTION
-- O DETERMINISTC SERVE PARA RETORNAR O MESMO RESULTADO SEMPRE QUE SÃO CHAMADAS COM UM CONJUNTO ESPECIAL DE VALORES DE ENTRADA


/*
STORED PROCEDURES

PERMITEM ALTERAR DE MANEIRA GLOBAL O NOSSO BANCO DE DADOS
SÃO SIMILARES A SCRIPTS
COM ELAS PODEMOS UTILIZAR INSTRUÇÕES COMO INSERT, UPDATE, DELETE
GERALMENTE SÃO UTILIZADAS PARA JUNTAR VÁRIAS QUERIES EM UM ÚNICO BLOCO DE CÓDIGO

EXEMPLO

DELIMITER $$

CREATE PROCEDURE NOME_STOREDPROCEDURE(PARAMETROS - PODE SER QUE TENHA)
BEGIN
	DECLARE VAR1 TIPO1;
    DECLARE VAR2 TIPO2;
    
    INSTRUÇÃO1;
    INSTRUÇÃO2;
    INSTRUÇÃO3;
END $$

DELIMITER ;

NÃO TEM RETURN POIS PODE RETORNAR UMA AÇÃO, UMA SÉRIE DE QUERIES OU INSTRUÇÕES
NÃO UTILIZAMOS SELECT, E SIM O COMANDO CALL
*/

-- EXEMPLO DE ATUALIZAÇÃO DE PREÇO
DELIMITER $$
CREATE PROCEDURE sp_AtualizaPreco(NovoPreco DECIMAL(10, 2), ID INT)
BEGIN
	-- CODIGO DE ATUALIZAÇÃO DE PREÇO
	UPDATE dCursos
    SET Preco_Curso = NovoPreco
    WHERE ID_Curso = ID;
    -- AGORA TEM DE ENVIAR UMA MENSAGEM DE EXECUTADO COM SUCESSO
	SELECT 'Preco atualizado';
END $$
DELIMITER ;
-- UTILIZANDO A FUNCAO
Select * from dcursos; -- PARA CHECAR OS PRECOS

CALL sp_AtualizaPreco(400, 1)
-- O PRECO NOVO E DEPOIS O ID DO CURSO.

/* EXEMPLO 2
CRIAR UM PROCEDURE QUE APLICA DESCONTO AO ID SELECIONADO

1 - CRIA-SE 2 VARIAVEIS LOCAIS: 1 PREÇO COM DESCONTO, 2 PREÇO ANTIGO
2 - ATRIBUI-SE O PRECO ANTIGO COM A SUBQUERIE À VARIAVEL DO PRECO ANTIGO
3 - ATRIBUIR O VALOR DE PRECO COM DESCONTO A VARIAVEL DO PRECO COM DESCONTO
4 - ATUALIZAR A TABELA COM O NOVO PRECO
5 - CRIA UNS TEXTOS PARA INFORMAR O QUE FOI FEITO, UTILIZANDO UMA SUBQUERIE PARA TRAZER O NOME DO CURSO (PODE SER FEITO COM UMA VARIAVEL TAMBEM)
*/

DELIMITER $$
CREATE PROCEDURE SP_DESCONTO(ID INT, DESCONTO decimal(10, 2))
BEGIN
	DECLARE VARPRECODESCONTO DECIMAL(10, 2);
    DECLARE VARPRECOANTIGO DECIMAL(10 , 2);
    
    SET VARPRECOANTIGO = (SELECT PRECO_CURSO FROM DCURSOS WHERE ID_CURSO = ID);
    SET VARPRECODESCONTO = (SELECT PRECO_CURSO FROM DCURSOS WHERE ID_CURSO = ID) * (1 - DESCONTO);
	SET VARNOMEDOCURSO = (SELECT NOME_CURSO FROM DCURSOS WHERE ID_CURSO = ID)
    
    UPDATE DCURSOS
    SET PRECO_CURSO = VARPRECODESCONTO
    WHERE ID_CURSO = ID;
    
    SELECT CONCAT('DESCONTO DE ', DESCONTO, ' APLICADO COM SUCESSO');
    SELECT CONCAT('CURSO: ', (SELECT NOME_CURSO FROM DCURSOS WHERE ID_CURSO = ID), '; PRECO ANTIGO= ', VARPRECOANTIGO, '; PRECO NOVO= ', VARPRECODESCONTO);
    SELECT 'CODIGO EXECUTADO COM SUCESSO';
END $$
DELIMITER ;

/*
AS VARIÁVES SÃO CRIADAS AQUI PARA FACILITAR O CALCULO E APLICAR AS ALTERAÇÕES, ENTÃO O PRIMEIRO PASSO É ATRIBUIR A ELAS O QUE SERÁ CALCULADO E ALTERADO

Para calcular o preço com o desconto aplicado, você não quer o valor do desconto em si, mas sim o que resta após o desconto.
O termo (1 - DESCONTO) está calculando o complemento de DESCONTO. Em termos percentuais, se o desconto é de 20% (ou 0,20), o complemento seria 80% (ou 1 - 0,20 = 0,80), 0,80 É O PERCENTUAL DO PRECO QUE RESTA APÓS O DESCONTO.
*/

-- ALTERANDO UMA PROCEDURE
-- CLICANDO nela e indo em alterar


/*
SUBQUERY

É UM SELECT DENTRO DE OUTRO SELECT
-- SELECT COLUNA FROM TABELA WHERE COLUNA = (SELECT COLUNA FROM TABELA....)
-- SELECT COLUNAS , (SELECT COLUNAS FROM TABELA...) FROM TABELA
-- SELECT COLUNAS FROM (SELECT COLUNAS FROM TABELA.... ) AS XXX;
*/

 -- EXEMPLO 1 - PEDIDOS DA LOJA ONDE O GERENTE É XXX
SELECT
	*
FROM PEDIDOS
WHERE ID_Loja = (SELECT ID_LOJA FROM LOJAS WHERE Gerente = 'Marcelo Castro');
-- Poderiamos ter criado uma variável para facilitar o código, daí troca apenas o nome do gerente na vaiavel e o código em si n porecisa ser alterado

-- EXEMPLO 2
-- PRODUTOS COM PREÇO UNITARIO ACIMA DA MÉDIA
SELECT 
	*
FROM PRODUTOS
WHERE PRECO_UNIT > (SELECT AVG(PRECO_UNIT) FROM PRODUTOS);

-- EXEMPLO 3
-- PRODUTOS DA CATEGORIA NOTEBOOKS
SELECT
	*
FROM PRODUTOS
WHERE ID_CATEGORIA =
				(SELECT ID_CATEGORIA
				FROM CATEGORIAS
				WHERE CATEGORIA = 'NOTEBOOK');


-- EXEMPLO 4
 -- DESCOBRIR CLIENTE QUE GEROU MAIS RECEITA
SELECT * FROM CLIENTES
WHERE ID_CLIENTE = 
	(SELECT	ID_CLIENTE
    FROM PEDIDOS
    GROUP BY ID_CLIENTE
    ORDER BY SUM(RECEITA_VENDA) DESC
    LIMIT 1
    );
-- O CALCULO AQUI APENAS SERVE PARA DEFINIR O AGRUPAMENTO. TEM DE CUIDAR COM A IDENTAÇÃO

-- exemplo 5
-- receita total dos produtos dell
SELECT * FROM PEDIDOS
WHERE ID_PRODUTO IN (1,4,5,14,15);
-- TORNANDO AUTOMATIZADO
SELECT SUM(RECEITA_VENDA) AS 'RECEITA MARCA DELL'
FROM PEDIDOS
WHERE ID_PRODUTO IN (
				SELECT
					ID_PRODUTO
                FROM PRODUTOS
                WHERE MARCA_PRODUTO = 'DELL'
                );
-- PRIMEIRO FIZEMOS UM SELECT PARA DESCOBRIR QUAIS OS PRODUTOS DELL
-- DEPOIS UM SELECT DO QUE QUERIAMOS E EM VEZ DE USAR OS IDS PARA A LISTA COM O COMANDO IN, UTILIZAMOS A SUBQUERIES.

-- EXEMPLO 6
-- PEDIDOS DA REIGÃO SUDESTE

SELECT * FROM PEDIDOS;
SELECT * FROM LOCAIS;
SELECT * FROM LOJAS;
-- PRIMEIRO SE ACHA AS LOJAS DO LOCAL SUDESTE
SELECT * FROM LOCAIS WHERE REGIÃO = 'SUDESTE';
-- DEPOIS SE ACHA OS IDS DAS LOJAS DO SUDESTE
SELECT
	ID_LOJA
FROM LOJAS
WHERE LOJA IN (
			SELECT CIDADE
            FROM LOCAIS
            WHERE REGIÃO = 'SUDESTE'
            );

-- DEPOIS FAZ O ULTIMO SELECT DOS PEDIDOS COM RESULTADO EM LISTA COLOCANDO A SUBQUERIE ALI PARA AJUSTAR AO QUE VIER
SELECT
	*
FROM PEDIDOS
WHERE ID_LOJA IN (SELECT
					ID_LOJA
					FROM LOJAS
					WHERE LOJA IN (
								SELECT CIDADE
								FROM LOCAIS
								WHERE REGIÃO = 'SUDESTE'
								)
				);
                
-- SUBQUERIE PARA CRIAR NOVA COLUNA
-- RETORNAR TABELA DE PRODUTOS + MEDIA DE PRECO_UNIT
-- PRIMEIRO FAZ A  MEDIA

SELECT AVG(PRECO_UNIT) FROM PRODUTOS;
-- DEPOIS FAZ A CONSULTA GERAL E INCLUI A MEDIA COMO SE FOSSE OUTRA COLUNA

SELECT
	*,
    (SELECT AVG(PRECO_UNIT) FROM PRODUTOS) AS 'MÉDIA PRECO UNITÁRIO'
FROM PRODUTOS;


/*
SUBQUERIES COMO TABELAS

É POSSÍVEL USAR UMA SUBQUERY COMO TABELA DE CONSULTA
É FEITO UMA QUERY, QUE VAI RETORNAR UMA CONSULTA
DESSA CONSULTA, PODE SER FEITO OUTROS CONSULTAS, SÓ QUE EM VEZ DE TABELAS UTILIZA-SE A SUBQUERY
*/

-- TOTAL DE VENDAS POR PRODUTO
-- PRIMEIRO ORGANIZA A TABELA ONDE SERÁ FEITA A CONSULTA
SELECT
	ID_PRODUTO,
    COUNT(*) AS 'Nº de Pedidos'
FROM PEDIDOS
GROUP BY ID_PRODUTO;
-- ESSA QUERY SERÁ UTILIZADA NO LUGAR DA TABELA NA PROXIMA QUERY

-- QUERY QUE UTILIZA SUBQUERY COMO TABELA
SELECT
	MAX(VENDAS) AS 'MÁXIMO DE VENDAS',
    MIN(VENDAS) AS 'MINIMO DE VENDAS',
    AVG(VENDAS) AS 'MÉDIA DE VENDAS'
FROM (
		SELECT
			ID_PRODUTO,
			COUNT(*) AS 'VENDAS'
		FROM PEDIDOS
		GROUP BY ID_PRODUTO
		) AS T;


/*
SUBQUERIES COM EXISTIS OU NOT EXISTS

QUANDOO É PRECISO DESCOBRIR SE UMA INFORMAÇÃO EXISTE OU NÃO

EXEMPLO:
VER SE TODAS AS CATEGORIAS POSSUEM AO MENOS UM EXEMPLAR DO PRODUTO
*/
SELECT * FROM CATEGORIAS;
SELECT * FROM PRODUTOS;

SELECT
	*
FROM CATEGORIAS
WHERE EXISTS (
			SELECT
				*
			FROM PRODUTOS
            WHERE CATEGORIAS.ID_CATEGORIA = PRODUTOS.ID_CATEGORIA
            );
-- NESSE CASO NA CONSULTA A TABELA CATEGORIAS, PERCEBE-SE QUE HÁ SETE CATEGORIAS
-- NA CONSULTA COM WHERE EXISTS É POSSÍVEL OBSERVAR QUE RETORNOU APENAS AS CATEGORIAS ONDE HÁ PRODUTOS.

